/*
 * utility to send MPEG TS to ITE it9507 DVB modulator (UT-100C USB stick)
 *
 * Copyright (c) 2015 Timo Ter√§s
 *
 * Based on the following GPL works:
 *  ITEtech IT9507 kernel driver (it950x_linux_v13.09.13.1)
 *  Dave Chapman's cleaned up driver (github.com/linuxstb/it9507)
 *
 * The driver is modified to be libusb based and heavily cleaned up.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 or later as
 * published by the Free Software Foundation.
 *
 * See http://www.gnu.org/ for license details.
 */

// FIXME: reboot for devices that do not need firmware load on connect

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <endian.h>
#include <getopt.h>

#include <libusb.h>

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

#define DVB_OFDM_VERSION		0xff090800U
#define DVB_LINK_VERSION		0xff270200U

/* Commands */
#define Command_REG_DEMOD_READ		0x0000
#define Command_REG_DEMOD_WRITE		0x0001
#define Command_REG_EEPROM_READ		0x0004
#define Command_REG_EEPROM_WRITE	0x0005
#define Command_IR_GET			0x0018
#define Command_QUERYINFO		0x0022
#define Command_BOOT			0x0023
#define Command_REBOOT			0x0023
#define Command_SCATTER_WRITE		0x0029
#define Command_GENERIC_READ		0x002A
#define Command_GENERIC_WRITE		0x002B
#define Processor_LINK			0x0000
#define Processor_OFDM			0x8000

/* GPIO Registers */
#define GPIO_I(x)			((x))
#define GPIO_O(x)			((x)+1)
#define GPIO_EN(x)			((x)+2)
#define GPIO_ON(x)			((x)+3)
#define GPIOH1				0xd8ae
#define GPIOH2				0xd8b6
#define GPIOH3				0xd8b2
#define GPIOH4				0xd8be
#define GPIOH5				0xd8ba
#define GPIOH6				0xd8c6
#define GPIOH7				0xd8c2
#define GPIOH8				0xd8ce

/* Define I2C master speed, the default value 0x07 means 366KHz (1000000000 / (24.4 * 16 * EagleUser_I2C_SPEED)). */
#define EagleUser_IIC_SPEED              0x07

/* biu_reg.h 8-30-2011
 * gen_biu Ver 1.0 generated by */
#define    p_eagle_reg_lnk2ofdm_data_63_56	0xF6A7

#define    p_eagle_reg_fec_sw_rst	0xF702
#define    p_eagle_reg_tps_gi	0xF725
#define    p_eagle_reg_iqik_c1_7_0	0xF752
#define    p_eagle_reg_iqik_c1_10_8	0xF753
#define    p_eagle_reg_iqik_c2_7_0	0xF754
#define    p_eagle_reg_iqik_c2_10_8	0xF755
#define    p_eagle_reg_iqik_c3_7_0	0xF756
#define    p_eagle_reg_iqik_c3_10_8	0xF757
#define    p_mp2if_mpeg_ser_mode	0xF985
#define	mp2if_mpeg_ser_mode_pos 0
#define	mp2if_mpeg_ser_mode_len 1
#define	mp2if_mpeg_ser_mode_lsb 0
#define    p_mp2if_mpeg_par_mode	0xF986
#define	mp2if_mpeg_par_mode_pos 0
#define	mp2if_mpeg_par_mode_len 1
#define	mp2if_mpeg_par_mode_lsb 0
#define    p_eagle_reg_mpeg_full_speed	0xF990
#define	eagle_reg_mpeg_full_speed_pos 0
#define	eagle_reg_mpeg_full_speed_len 1
#define	eagle_reg_mpeg_full_speed_lsb 0
#define    p_eagle_reg_mp2_sw_rst	0xF99D
#define	eagle_reg_mp2_sw_rst_pos 0
#define	eagle_reg_mp2_sw_rst_len 1
#define	eagle_reg_mp2_sw_rst_lsb 0
#define    p_eagle_reg_mp2if2_en	0xF9A3
#define	eagle_reg_mp2if2_en_pos 0
#define	eagle_reg_mp2if2_en_len 1
#define	eagle_reg_mp2if2_en_lsb 0
#define    p_eagle_reg_mp2if2_sw_rst	0xF9A4
#define	eagle_reg_mp2if2_sw_rst_pos 0
#define	eagle_reg_mp2if2_sw_rst_len 1
#define	eagle_reg_mp2if2_sw_rst_lsb 0
#define    p_eagle_reg_mp2if2_half_psb	0xF9A5
#define	eagle_reg_mp2if2_half_psb_pos 0
#define	eagle_reg_mp2if2_half_psb_len 1
#define	eagle_reg_mp2if2_half_psb_lsb 0
#define    p_eagle_reg_mp2if_stop_en	0xF9B5
#define	eagle_reg_mp2if_stop_en_pos 0
#define	eagle_reg_mp2if_stop_en_len 1
#define	eagle_reg_mp2if_stop_en_lsb 0
#define    p_eagle_reg_sys_buf_overflow	0xF9B9
#define	eagle_reg_sys_buf_overflow_pos 0
#define	eagle_reg_sys_buf_overflow_len 1
#define	eagle_reg_sys_buf_overflow_lsb 0
#define    p_eagle_reg_tsip_en	0xF9CC
#define	eagle_reg_tsip_en_pos 0
#define	eagle_reg_tsip_en_len 1
#define	eagle_reg_tsip_en_lsb 0
#define    p_eagle_reg_tsis_en	0xF9CD
#define	eagle_reg_tsis_en_pos 0
#define	eagle_reg_tsis_en_len 1
#define	eagle_reg_tsis_en_lsb 0
#define    p_eagle_reg_ts_in_src	0xF9D8
#define eagle_reg_tx_fifo_overflow	0xF9E7
#define    p_eagle_reg_afe_mem0	0xFB24
#define    p_eagle_reg_afe_mem1	0xFB25
#define    p_eagle_reg_dyn0_clk	0xFBA8

// biu_reg.h 6-29-2010
// gen_biu Ver 1.0 generated by weili.su
#define    p_eagle_reg_top_padmiscdr2	0xD830
#define    p_eagle_reg_top_padmiscdr4	0xD831
#define    p_eagle_reg_top_padmiscdr8	0xD832
#define    p_eagle_reg_top_padmiscdrsr	0xD833
#define    p_eagle_reg_top_lock3_out	0xD8FD
#define    p_eagle_reg_top_hostb_mpeg_par_mode	0xD91B
#define	eagle_reg_top_hostb_mpeg_par_mode_pos 0
#define	eagle_reg_top_hostb_mpeg_par_mode_len 1
#define	eagle_reg_top_hostb_mpeg_par_mode_lsb 0
#define    p_eagle_reg_top_hostb_mpeg_ser_mode	0xD91C
#define	eagle_reg_top_hostb_mpeg_ser_mode_pos 0
#define	eagle_reg_top_hostb_mpeg_ser_mode_len 1
#define	eagle_reg_top_hostb_mpeg_ser_mode_lsb 0
#define    p_eagle_reg_top_host_reverse	0xD920

#define    p_eagle_reg_dvbt_en	0xF41A
#define	eagle_reg_dvbt_en_pos 0
#define	eagle_reg_dvbt_en_len 1
#define	eagle_reg_dvbt_en_lsb 0
#define    p_eagle_reg_dvbt_inten	0xF41F
#define	eagle_reg_dvbt_inten_pos 2
#define	eagle_reg_dvbt_inten_len 1
#define	eagle_reg_dvbt_inten_lsb 0

// usb_biu_reg.h 8-1-2011
// gen_biu Ver 1.0 generated by cphsu
#define    p_eagle_reg_ep5_max_pkt	0xDD0D
#define    p_eagle_reg_ep6_max_pkt	0xDD0E
#define    p_eagle_reg_ep5_tx_en	0xDD11
#define	eagle_reg_ep5_tx_en_pos 6
#define	eagle_reg_ep5_tx_en_len 1
#define	eagle_reg_ep5_tx_en_lsb 0
#define    p_eagle_reg_ep6_rx_en	0xDD11
#define	eagle_reg_ep6_rx_en_pos 7
#define	eagle_reg_ep6_rx_en_len 1
#define	eagle_reg_ep6_rx_en_lsb 0
#define    p_eagle_reg_ep5_tx_nak	0xDD13
#define	eagle_reg_ep5_tx_nak_pos 6
#define	eagle_reg_ep5_tx_nak_len 1
#define	eagle_reg_ep5_tx_nak_lsb 0
#define    p_eagle_reg_ep6_rx_nak	0xDD13
#define	eagle_reg_ep6_rx_nak_pos 7
#define	eagle_reg_ep6_rx_nak_len 1
#define	eagle_reg_ep6_rx_nak_lsb 0
#define    p_eagle_reg_ep5_tx_len_7_0	0xDD8A
#define    p_eagle_reg_ep5_tx_len_15_8	0xDD8B
#define    p_eagle_reg_ep6_cnt_num_7_0	0xDDA9

#define OVA_BASE			0x4C00			/* omega variable address base */
#define OVA_EEPROM_CFG			(OVA_BASE-620)		/* 256 bytes */
#define OVA_SECOND_DEMOD_I2C_ADDR	(OVA_BASE-5)

#define second_i2c_address		OVA_SECOND_DEMOD_I2C_ADDR /* 0x417F */
#define chip_version_7_0		0x1222

/* Define USB frame size */
#define EagleUser_USB20_MAX_PACKET_SIZE      512
#define EagleUser_USB20_FRAME_SIZE           (188 * 348)
#define EagleUser_USB20_FRAME_SIZE_DW        (EagleUser_USB20_FRAME_SIZE / 4)

struct it950x_dev {
	libusb_device_handle *dev;
	long int capacity_bps;

	/* Configurable modulation parameters */
	int gain;
	int frequency_khz;
	int bandwidth_hz;
	int transmission_mode;
	int constellation;
	int guard_interval;
	int code_rate_hp;
	int cell_id;

	/* State */
	int error;
	uint16_t c1val, c2val, c3val;
};

#define IT950X_TRANSMISSION_MODE_2K		0
#define IT950X_TRANSMISSION_MODE_4K		2
#define IT950X_TRANSMISSION_MODE_8K		1

#define IT950X_CONSTELLATION_QPSK		0
#define IT950X_CONSTELLATION_QAM_16		1
#define IT950X_CONSTELLATION_QAM_64		2

#define IT950X_GUARD_INTERVAL_1_4		3
#define IT950X_GUARD_INTERVAL_1_8		2
#define IT950X_GUARD_INTERVAL_1_16		1
#define IT950X_GUARD_INTERVAL_1_32		0

#define IT950X_FEC_1_2				0
#define IT950X_FEC_2_3				1
#define IT950X_FEC_3_4				2
#define IT950X_FEC_5_6				3
#define IT950X_FEC_7_8				4

static int verbose;

struct it950x_req {
	uint8_t length;
	uint16_t command;
	uint8_t seq;
	uint8_t payload[251];
	/* last two bytes of payload is checksum */
} __attribute__((__packed__));

struct it950x_reply {
	uint8_t length;
	uint8_t seq;
	uint8_t status;
	uint8_t payload[251];
	/* last two bytes of payload is checksum */
} __attribute__((__packed__));

#define EagleUser_MAX_PKT_SIZE			255
#define EagleUser_MAXFRAMESIZE			63

static uint16_t it9507_checksum(const void *ptr, size_t len)
{
	uint8_t *pdu = (uint8_t *) ptr;
	uint16_t *pdu16 = (uint16_t *) ptr, csum = 0;
	size_t i;

	for (i = 0; i < len / 2; i++)
		csum += be16toh(pdu16[i]);
	if (len & 1)
		csum += pdu[len-1] << 8;

	return ~csum;
}

static void hexdump(const char *msg, const char *ptr, size_t ptrlen)
{
	int i;

	if (verbose < 3)
		return;

	fprintf(stderr, "%s:", msg);
	for (i = 0; i < ptrlen; i++)
		fprintf(stderr, " %02x", (unsigned char) ptr[i]);
	fprintf(stderr, "\n");
}

static int it9507_bus_tx(struct it950x_dev *dev, void *ptr, size_t len)
{
	int r, actual;

	if (dev->error) return dev->error;

	hexdump("TX", ptr, len);
	r = libusb_bulk_transfer(dev->dev, LIBUSB_ENDPOINT_OUT | 0x02,
				 ptr, len, &actual, 1000);
	if (r != LIBUSB_SUCCESS)
		return dev->error = -EIO;
	return actual;
}

static int it9507_bus_rx(struct it950x_dev *dev, void *ptr, size_t len)
{
	int r, actual;

	if (dev->error) return dev->error;

	r = libusb_bulk_transfer(dev->dev, LIBUSB_ENDPOINT_IN | 0x01,
				 ptr, len, &actual, 1000);
	if (r != LIBUSB_SUCCESS)
		return dev->error = -EIO;
	hexdump("RX", ptr, actual);
	return actual;
}

static int it9507_talk(struct it950x_dev *dev, struct it950x_req *req, struct it950x_reply *rep)
{
	static uint16_t seq = 0;
	uint16_t csum;
	int r;

	if (dev->error) return dev->error;

	req->seq = seq++;
	csum = it9507_checksum(&req->command, req->length+3);

	req->payload[req->length] = csum >> 8;
	req->payload[req->length+1] = csum & 0xff;
	req->length += 3 + 2;

	/* Send data */
	r = it9507_bus_tx(dev, req, req->length + 1);
	if (r < 0) goto err;
	if (r != req->length + 1) goto errio;
	if (rep == NULL) return 0;

	/* Read data */
	r = it9507_bus_rx(dev, rep, sizeof(*rep));
	if (r < 3+2) goto errio;
	if (rep->length > r) goto errio;

	csum = it9507_checksum(&rep->seq, rep->length - 2);
	rep->length -= 2 + 2;
	if ((rep->payload[rep->length] << 8) + rep->payload[rep->length+1] != csum)
		goto errio;
	if (rep->status)
		goto errio;

	return 0;
errio:
	r = -EIO;
err:
	dev->error = r;
	return r;
}

static int it950x_wr_regs(struct it950x_dev *dev, uint16_t cpu, uint32_t reg, uint8_t *values, uint8_t num)
{
	struct it950x_req req;
	struct it950x_reply rep;

	req.command = htobe16(cpu | Command_REG_DEMOD_WRITE);
	req.length = 6 + num;
	req.payload[0] = num;
	req.payload[1] = (cpu != Processor_LINK || reg >= 0x100) ? 2 : 1;
	req.payload[2] = reg >> 24;
	req.payload[3] = reg >> 16;
	req.payload[4] = reg >> 8;
	req.payload[5] = reg;
	memcpy(&req.payload[6], values, num);

	if (verbose >= 2) {
		int i;
		fprintf(stderr, "WriteRegs @%04x:", reg);
		for (i = 0; i < num; i++) fprintf(stderr, " %02x", values[i]);
		fprintf(stderr, "\n");
	}

	return it9507_talk(dev, &req, &rep);
}

static int it950x_rd_regs(struct it950x_dev *dev, uint16_t cpu, uint32_t reg, uint8_t *values, uint8_t num)
{
	struct it950x_req req;
	struct it950x_reply rep;
	int r;

	req.command = htobe16(cpu | Command_REG_DEMOD_READ);
	req.length = 6;
	req.payload[0] = num;
	req.payload[1] = (cpu != Processor_LINK || reg >= 0x100) ? 2 : 1;
	req.payload[2] = reg >> 24;
	req.payload[3] = reg >> 16;
	req.payload[4] = reg >> 8;
	req.payload[5] = reg;

	r = it9507_talk(dev, &req, &rep);
	if (r < 0) return r;

	if (rep.length != num) return -EIO;
	memcpy(values, rep.payload, num);

	if (verbose >= 2) {
		int i;
		fprintf(stderr, "ReadRegs @%04x:", reg);
		for (i = 0; i < num; i++) fprintf(stderr, " %02x", values[i]);
		fprintf(stderr, "\n");
	}

	return 0;
}

static int it950x_wr_reg(struct it950x_dev *dev, uint16_t cpu, uint32_t reg, uint8_t value)
{
	return it950x_wr_regs(dev, cpu, reg, &value, 1);
}

static int it950x_wr_regbits(struct it950x_dev *dev, uint16_t cpu, uint32_t reg, uint8_t pos, uint8_t len, uint8_t val)
{
	uint8_t oldval;
	int r;

	r = it950x_rd_regs(dev, cpu, reg, &oldval, 1);
	if (r < 0) return r;

	oldval &= ~((0xff >> (8-len)) << pos);

	return it950x_wr_reg(dev, cpu, reg, oldval | (val << pos));
}

static uint32_t it9507_get_fwver(struct it950x_dev *dev, uint16_t cpu)
{
	struct it950x_req req;
	struct it950x_reply rep;
	int r;

	req.command = htobe16(cpu | Command_QUERYINFO);
	req.length = 1;
	req.payload[0] = 1;

	r = it9507_talk(dev, &req, &rep);
	if (r < 0) return -1;
	if (rep.length != 4) return -1;
	return rep.payload[0] << 24 | rep.payload[1] << 16 | rep.payload[2] << 8 | rep.payload[3];
}

static int it950x_load_firmware(struct it950x_dev *dev)
{
	/* ITE driver uploads 23 chunks of 48 bytes, then 1 chunk of 14,
	   then 71 chunks of 48 bytes, then 1 chunk of 34. */
	#include "firmware.h"
	static const int chunk_sizes[] = {
		48, 23,
		14, 1,
		48, 71,
		34, 1,
		0
	};
	const uint8_t *p;
	struct it950x_req req;
	struct it950x_reply rep;
	int r, i, j;

	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_lnk2ofdm_data_63_56, EagleUser_IIC_SPEED);

	p = EagleFirmware_codes;
	for (j = 0; chunk_sizes[j]; j += 2) {
		for (i = 0; i < chunk_sizes[j + 1]; i++) {
			req.command = htobe16(Processor_LINK | Command_SCATTER_WRITE);
			req.length = chunk_sizes[j];
			memcpy(req.payload, p, req.length);

			if (it9507_talk(dev, &req, &rep) < 0)
				return dev->error;

			p += chunk_sizes[j];
		}
	}

	req.command = htobe16(Processor_LINK | Command_BOOT);
	req.length = 0;
	r = it9507_talk(dev, &req, &rep);
	if (r == 0) usleep(10000);
	return r;
}

static int it9507_power_up(struct it950x_dev *dev)
{
	/* Power up case */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_afe_mem0, 3, 1, 0);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_dyn0_clk, 0);

	/* Fixed current leakage */
	it950x_wr_regbits(dev, Processor_LINK,
			p_eagle_reg_top_hostb_mpeg_ser_mode,
			eagle_reg_top_hostb_mpeg_ser_mode_pos,
			eagle_reg_top_hostb_mpeg_ser_mode_len, 0);

	/* Disable HostB parallel */
	it950x_wr_regbits(dev, Processor_LINK,
			p_eagle_reg_top_hostb_mpeg_par_mode,
			eagle_reg_top_hostb_mpeg_par_mode_pos,
			eagle_reg_top_hostb_mpeg_par_mode_len, 0);

	return dev->error;
}

static int it9507_disable_xmit(struct it950x_dev *dev)
{
	it950x_wr_reg(dev, Processor_LINK, 0xDDAB, 1);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_fec_sw_rst, 1);

	/* afe Power down */
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_afe_mem0, 1);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_afe_mem1, 0xFE);

	/* RF power down */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH2), 0);

	usleep(100000);
	return dev->error;
}

static int it9507_enable_xmit(struct it950x_dev *dev)
{
	/* afe Power up */
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_afe_mem0, 0);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_afe_mem1, 0xFC);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_fec_sw_rst, 0);
	it950x_wr_reg(dev, Processor_LINK, 0xDDAB, 0);

	/* clear */
	it950x_wr_reg(dev, Processor_OFDM, eagle_reg_tx_fifo_overflow, 1);

	/* RF power up */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH2), 1);

	usleep(100000);
	return dev->error;
}

unsigned int IT9507_getLoFreq(unsigned int rf_freq_kHz)
{
	static const unsigned char nvmap[] = { 48, 32, 24, 16, 12, 8, 6, 4, 2, 2 };
	unsigned int c_fN_min[9];
	unsigned int nc, nv, mv, lo_freq;
	unsigned long tmp_tg, tmp_cal, tmp_m;
	unsigned int m_bdry;
	unsigned long tmp_numer;
	unsigned int g_fxtal_kHz = 2000;
	unsigned int g_fdiv = 3;

	m_bdry = 3660;
	tmp_numer = (unsigned long)g_fxtal_kHz *(unsigned long)m_bdry;

	c_fN_min[7] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 4));
	c_fN_min[6] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 6));
	c_fN_min[5] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 8));
	c_fN_min[4] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 12));
	c_fN_min[3] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 16));
	c_fN_min[2] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 24));
	c_fN_min[1] = (unsigned int)(tmp_numer / ((unsigned long)g_fdiv * 32));
	c_fN_min[0] = 0;

	for (nc = 0; nc < 7 && rf_freq_kHz > c_fN_min[nc+1]; nc++)
		;
	nv = nvmap[nc];

	if (nc == 8) nc = 0;
	tmp_tg = (unsigned long)rf_freq_kHz *(unsigned long)nv * (unsigned long)g_fdiv;
	tmp_m = tmp_tg / (unsigned long)g_fxtal_kHz;
	tmp_cal = tmp_m * (unsigned long)g_fxtal_kHz;
	if (tmp_tg - tmp_cal >= (g_fxtal_kHz >> 1))
		tmp_m = tmp_m + 1;
	mv = (unsigned int)tmp_m;
	lo_freq = (((nc) & 0x07) << 13) + mv;
	if (verbose) fprintf(stderr, "lo_freq=%04x, for %d kHz\n", lo_freq, rf_freq_kHz);
	return lo_freq;
}

static int it9507_set_bandwidth(struct it950x_dev *dev)
{
	static const struct {
		int bandwidth;
		uint8_t regs[5];
	} configs[] = {
		{ 1000, { 0x5e, 0x03, 0x01, 0x03, 0x00 } },
		{ 1500, { 0x6e, 0x03, 0x01, 0x03, 0x00 } },
		{ 2000, { 0x5e, 0x01, 0x01, 0x03, 0x00 } },
		{ 2500, { 0x66, 0x01, 0x01, 0x03, 0x00 } },
		{ 3000, { 0x6e, 0x01, 0x01, 0x03, 0x00 } },
		{ 4000, { 0x5e, 0x01, 0x01, 0x03, 0x01 } },
		{ 5000, { 0x66, 0x01, 0x01, 0x03, 0x01 } },
		{ 6000, { 0x6e, 0x01, 0x01, 0x03, 0x01 } },
		{ 7000, { 0x76, 0x02, 0x01, 0x03, 0x02 } },
		{ 8000, { 0x1e, 0x02, 0x01, 0x03, 0x02 } },
	};
	int cfg;

	for (cfg = 0; cfg < sizeof(configs)/sizeof(configs[0]); cfg++)
		if (configs[cfg].bandwidth == dev->bandwidth_hz)
			break;
	if (cfg >= sizeof(configs)/sizeof(configs[0]))
		return -EINVAL;

	it950x_wr_reg(dev, Processor_LINK, 0xD812, 3);
	it950x_wr_reg(dev, Processor_OFDM, 0xFBB6, configs[cfg].regs[0]);
	it950x_wr_regbits(dev, Processor_OFDM, 0xFBB7, 0, 2, configs[cfg].regs[1]);
	it950x_wr_regbits(dev, Processor_OFDM, 0xFBB8, 2, 1, configs[cfg].regs[2]);
	it950x_wr_reg(dev, Processor_OFDM, 0xF741, configs[cfg].regs[4]);
	it950x_wr_reg(dev, Processor_LINK, 0xD814, configs[cfg].regs[3]);
	it950x_wr_regbits(dev, Processor_OFDM, 0xFBB8, 2, 1, 0);

	return dev->error;
}

static int it950x_read_calibration_info(struct it950x_dev *dev)
{
	uint8_t val[2];
	int r;

	r = it950x_rd_regs(dev, Processor_OFDM, p_eagle_reg_iqik_c1_7_0, val, 2);
	if (r < 0) return r;
	dev->c1val = (val[1] << 8) | val[0];

	r = it950x_rd_regs(dev, Processor_OFDM, p_eagle_reg_iqik_c2_7_0, val, 2);
	if (r < 0) return r;
	dev->c2val = (val[1] << 8) | val[0];

	r = it950x_rd_regs(dev, Processor_OFDM, p_eagle_reg_iqik_c3_7_0, val, 2);
	if (r < 0) return r;
	dev->c3val = (val[1] << 8) | val[0];

	if (verbose) fprintf(stderr, "Calibration = %x %x %x\n", dev->c1val, dev->c2val,dev->c3val);

	return 0;
}

static int setIO(const int THETA)
{
	int reverse, sign;
	int x_in, x_in_reverse;
	int mi, xi, yi, ph2amp;

	if ((0 <= THETA) && (THETA < 4096)) {	// 0 ~ 4096
		reverse = 0;
		sign = 1;
	} else if ((4096 <= THETA) && (THETA < 8192)) {	// 4096 ~ 8192
		reverse = 1;
		sign = 1;
	} else if ((8192 <= THETA) && (THETA < 12288)) {	// 8192 ~ 12288
		reverse = 0;
		sign = -1;
	} else {
		reverse = 1;
		sign = -1;
	}

	//x_in = ( double ) ( ( int ) THETA % 4096 );
	x_in = ((int)THETA % 4096);
	if (reverse == 0)
		x_in_reverse = x_in;
	else
		x_in_reverse = 4096 - x_in;

	if ((0 <= x_in_reverse) && (x_in_reverse < 256)) {	// section 1 : 0 ~ 256
		mi = 25 * 16;
		xi = 256 * 0;
		yi = 0 * 16;
	} else if ((256 <= x_in_reverse) && (x_in_reverse < 512)) {	// section 2 : 256 ~ 512
		mi = 25 * 16;
		xi = 256 * 1;
		yi = 400 * 16;
	} else if ((512 <= x_in_reverse) && (x_in_reverse < 768)) {	// section 3 : 512 ~ 768
		mi = 24 * 16;
		xi = 256 * 2;
		yi = 801 * 16;
	} else if ((768 <= x_in_reverse) && (x_in_reverse < 1024)) {	// section 4 : 768 ~ 1024
		mi = 24 * 16;
		xi = 256 * 3;
		yi = 1186 * 16;
	} else if ((1024 <= x_in_reverse) && (x_in_reverse < 1280)) {	// section 5 : 1024 ~ 1280
		mi = 23 * 16;
		xi = 256 * 4;
		yi = 1564 * 16;
	} else if ((1280 <= x_in_reverse) && (x_in_reverse < 1536)) {	// section 6 : 1280 ~ 1536
		mi = 22 * 16;
		xi = 256 * 5;
		yi = 1927 * 16;
	} else if ((1536 <= x_in_reverse) && (x_in_reverse < 1792)) {	// section 7 : 1536 ~ 1792
		mi = 20 * 16;
		xi = 256 * 6;
		yi = 2277 * 16;
	} else if ((1792 <= x_in_reverse) && (x_in_reverse < 2048)) {	// section 8 : 1792 ~ 2048
		mi = 19 * 16;
		xi = 256 * 7;
		yi = 2595 * 16;
	} else if ((2048 <= x_in_reverse) && (x_in_reverse < 2304)) {	// section 9 : 2048 ~ 2304
		mi = 17 * 16;
		xi = 256 * 8;
		yi = 2894 * 16;
	} else if ((2304 <= x_in_reverse) && (x_in_reverse < 2560)) {	// section 10 : 2304 ~ 2560
		mi = 15 * 16;
		xi = 256 * 9;
		yi = 3165 * 16;
	} else if ((2560 <= x_in_reverse) && (x_in_reverse < 2816)) {	// section 11 : 2560 ~ 2816
		mi = 13 * 16;
		xi = 256 * 10;
		yi = 3405 * 16;
	} else if ((2816 <= x_in_reverse) && (x_in_reverse < 3072)) {	// section 12 : 2816 ~ 3072
		mi = 11 * 16;
		xi = 256 * 11;
		yi = 3609 * 16;
	} else if ((3072 <= x_in_reverse) && (x_in_reverse < 3328)) {	// section 13 : 3072 ~ 3328
		mi = 8 * 16;
		xi = 256 * 12;
		yi = 3788 * 16;
	} else if ((3328 <= x_in_reverse) && (x_in_reverse < 3584)) {	// section 14 : 3328 ~ 3584
		mi = 6 * 16;
		xi = 256 * 13;
		yi = 3920 * 16;
	} else if ((3584 <= x_in_reverse) && (x_in_reverse < 3840)) {	// section 15 : 3584 ~ 3840
		mi = 4 * 16;
		xi = 256 * 14;
		yi = 4015 * 16;
	} else {			// section 16 : 3840 ~ 4096
		mi = 1 * 16;
		xi = 256 * 15;
		yi = 4078 * 16;
	}

	ph2amp = sign * (mi * (x_in_reverse - xi) / 16 + yi);

	return ph2amp;
}

typedef struct {
	int frequency;
	int dAmp;
	int dPhi;
} IQtable;

static const IQtable IQ_fixed_table0[] = {
	{50000, 45, -1038},
	{60000, 17, -664},
	{70000, 3, -291},
	{80000, 0, 82},
	{90000, 6, 419},
	{100000, 23, 774},
	{110000, 26, 801},
	{120000, 22, 737},
	{130000, 17, 655},
	{140000, 12, 564},
	{150000, 9, 473},
	{160000, 6, 382},
	{170000, 4, 300},
	{180000, 2, 218},
	{190000, 1, 146},
	{200000, 1, 82},
	{210000, 1, 0},
	{220000, 1, -55},
	{230000, 1, -109},
	{240000, 2, -155},
	{250000, 2, -200},
	{260000, 3, -237},
	{270000, 3, -273},
	{280000, 4, -300},
	{290000, 4, -319},
	{300000, 5, -337},
	{310000, 5, -337},
	{320000, 4, -346},
	{330000, 4, -337},
	{340000, 4, -328},
	{350000, 4, -319},
	{360000, 4, -300},
	{370000, 3, -282},
	{380000, 2, -273},
	{390000, 2, -237},
	{400000, 1, -228},
	{410000, 1, -191},
	{420000, 1, -173},
	{430000, 0, -146},
	{440000, 0, -118},
	{450000, 0, -91},
	{460000, 0, -73},
	{470000, 0, -55},
	{480000, 0, -36},
	{490000, 0, -36},
	{500000, -1, -18},
	{510000, 0, -9},
	{520000, 0, 0},
	{530000, -1, 0},
	{540000, 0, 0},
	{550000, -1, -9},
	{560000, -1, 18},
	{570000, -1, -9},
	{580000, 0, 9},
	{590000, 0, 18},
	{600000, 0, 0},
	{610000, 0, 18},
	{620000, 0, 0},
	{630000, -1, 0},
	{640000, 0, -9},
	{650000, 0, 9},
	{660000, 0, -9},
	{670000, 0, 0},
	{680000, 0, 0},
	{690000, 0, 0},
	{700000, 0, 0},
	{710000, 0, 0},
	{720000, 0, 9},
	{730000, 0, -9},
	{740000, 0, 9},
	{750000, 0, -18},
	{760000, 0, -27},
	{770000, 2, -18},
	{780000, 0, -18},
	{790000, 2, -18},
	{800000, 0, -18},
	{810000, 0, -18},
	{820000, 1, -18},
	{830000, 0, -27},
	{840000, 0, 0},
	{850000, 2, -27},
	{860000, 0, -27},
	{870000, 1, -27},
	{880000, 0, -36},
	{890000, 0, -27},
	{900000, 0, 0},
	{910000, 1, -18},
	{920000, 1, -27},
	{930000, 0, -36},
	{940000, 0, -27},
	{950000, 0, -27},
	{1500000, 0, -27},
};

static int interpolation(int fIn, int *ptrdAmp, int *ptrdPhi)
{
	const IQtable *iqtable = IQ_fixed_table0;
	const int num_entries = sizeof(IQ_fixed_table0) / sizeof(IQ_fixed_table0[0]);
	int outdAmp;
	int outdPhi;
	int diff;
	int temp1, temp2, temp3, temp4;
	int i;

	for (i = 0; iqtable[i].frequency && i+1 < num_entries; i++) {
		if (fIn >= iqtable[i].frequency && fIn < iqtable[i+1].frequency)
			break;
	}
	if (fIn < iqtable[i].frequency || fIn > iqtable[i+1].frequency)
		return -1;
	if (fIn != iqtable[i].frequency &&
	    iqtable[i+1].frequency - iqtable[i].frequency > 100000)
		return -1;

	if (verbose) fprintf(stderr, "Found: %d \t %d\n", iqtable[i].frequency, iqtable[i+1].frequency);

	// Perform linear interpolation
	temp1 = iqtable[i].dAmp;
	temp2 = fIn - iqtable[i].frequency;
	temp3 = iqtable[i+1].dAmp - iqtable[i].dAmp;
	temp4 = iqtable[i+1].frequency - iqtable[i].frequency;
	outdAmp = temp1 + temp2 * temp3 / temp4;

	//outdAmp = state->calibrationInfo.ptrIQtableEx[idx].dAmp + ((fIn - (int)state->calibrationInfo.ptrIQtableEx[idx].frequency)
	//             * (state->calibrationInfo.ptrIQtableEx[idx+1].dAmp - state->calibrationInfo.ptrIQtableEx[idx].dAmp)) / (state->calibrationInfo.ptrIQtableEx[idx+1].frequency - state->calibrationInfo.ptrIQtableEx[idx].frequency);
	diff = iqtable[i+1].dPhi - iqtable[i].dPhi;
	if (diff <= -8192) {
		diff = diff + 16384;
	} else if (diff >= 8192) {
		diff = diff - 16384;
	}
	//outdPhi = IQ_table[idx][2] + (fIn - IQ_table[idx][0]) * (IQ_table[idx+1][2] - IQ_table[idx][2]) / (IQ_table[idx+1][0] - IQ_table[idx][0]);

	//------test---------
	temp1 = iqtable[i].dPhi;
	temp2 = fIn - iqtable[i].frequency;
	temp3 = diff;
	temp4 = iqtable[i+1].frequency - iqtable[i].frequency;
	outdPhi = temp1 + temp2 * temp3 / temp4;
	//----------------

	//outdPhi = state->calibrationInfo.ptrIQtableEx[idx].dPhi + ((fIn - (int)state->calibrationInfo.ptrIQtableEx[idx].frequency) * diff) / (state->calibrationInfo.ptrIQtableEx[idx+1].frequency - state->calibrationInfo.ptrIQtableEx[idx].frequency);
	if (outdPhi >= 16384) {
		outdPhi = outdPhi % 16384;
	}
	while (outdPhi < 0) {
		outdPhi = outdPhi + 16384;
	}
	*ptrdAmp = outdAmp;
	*ptrdPhi = outdPhi;

	return 0;
}

static int EagleTuner_setIQCalibration(struct it950x_dev *dev)
{
	uint8_t val[6];
	int dAmp = 0, dPhi = 0;
	int alpha, beta;
	int c1, c2, c3;
	int test, test2;

	if (interpolation(dev->frequency_khz, &dAmp, &dPhi) < 0) {
		//out of range --> set to default
		val[0] = 0x00;
		val[1] = 0x02;
		val[2] = 0x00;
		val[3] = 0x00;
		val[4] = 0x00;
		val[5] = 0x02;
		it950x_wr_regs(dev, Processor_OFDM, 0, val, 6);
		return -1;
	}

	alpha = 512 - dAmp;
	beta = 512 + dAmp;

	test = setIO(dPhi);

	dPhi = dPhi + 4096;
	if (dPhi >= 16384) {
		dPhi = dPhi % 16384;
	}

	test2 = setIO(dPhi);

#define BYTESHIFT 512
	c1 = (int)(alpha * beta / 16 * test2 / 4096 / BYTESHIFT);
	c2 = (int)(-1 * alpha * beta / 16 * test / 4096 / BYTESHIFT);
	c3 = (int)(alpha * alpha / BYTESHIFT);

	if (c1 < 0) c1 = c1 + 2048;
	if (c2 < 0) c2 = c2 + 2048;
	if (c3 < 0) c3 = c3 + 2048;

	val[0] = c1 & 0xff;
	val[1] = c1 >> 8;
	val[2] = c2 & 0xff;
	val[3] = c2 >> 8;
	val[4] = c3 & 0xff;
	val[5] = c3 >> 8;
	it950x_wr_regs(dev, Processor_OFDM, p_eagle_reg_iqik_c1_7_0, val, 6);

	return dev->error;
}

static int it9507_set_frequency(struct it950x_dev *dev)
{
	unsigned int freq_code;

	freq_code = IT9507_getLoFreq(dev->frequency_khz);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2A, freq_code & 0xff);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2B, freq_code >> 8);
	it950x_wr_regbits(dev, Processor_OFDM, 0xFB2C, 2, 1, dev->frequency_khz > 950000 ? 1 : 0);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2D, 2);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2D, 1);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2D, 0);

	EagleTuner_setIQCalibration(dev);

	it950x_read_calibration_info(dev);

	return dev->error;
}

static int it9507_configure(struct it950x_dev *dev)
{
	it9507_set_bandwidth(dev);
	it9507_set_frequency(dev);

	/* EagleUser_acquireChannel: set uvFilter */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH8), dev->frequency_khz <= 300000 ? 0 : 1);

	/* Configure modulation */
	it9507_disable_xmit(dev);
	it950x_wr_reg(dev, Processor_OFDM, 0xf721, dev->constellation);
	it950x_wr_reg(dev, Processor_OFDM, 0xf723, dev->code_rate_hp);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_tps_gi, dev->guard_interval);
	it950x_wr_reg(dev, Processor_OFDM, 0xf726, dev->transmission_mode);
	it950x_wr_reg(dev, Processor_OFDM, 0xf7C1, 1 << (3 - dev->guard_interval));
	it950x_wr_reg(dev, Processor_OFDM, 0xf7C6, 1);
	it950x_wr_reg(dev, Processor_OFDM, 0xF727, dev->cell_id >> 8);
	it950x_wr_reg(dev, Processor_OFDM, 0xF728, dev->cell_id);
	return it9507_enable_xmit(dev);
}

static int it950x_set_ts_interface(struct it950x_dev *dev)
{
	uint16_t frameSize;
	uint8_t packetSize, buffer[2];

	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_dvbt_inten,
			eagle_reg_dvbt_inten_pos, eagle_reg_dvbt_inten_len,
			1);

	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mpeg_full_speed,
			eagle_reg_mpeg_full_speed_pos, eagle_reg_mpeg_full_speed_len,
			0);

	/* Enable DVB-T mode */
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_dvbt_en,
			eagle_reg_dvbt_en_pos, eagle_reg_dvbt_en_len,
			1);
	it950x_wr_regbits(dev, Processor_OFDM, p_mp2if_mpeg_ser_mode,
			mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len,
			0);
	it950x_wr_regbits(dev, Processor_OFDM, p_mp2if_mpeg_par_mode,
			mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len,
			0);

	/* Fix current leakage */
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_top_hostb_mpeg_ser_mode,
			eagle_reg_top_hostb_mpeg_ser_mode_pos, eagle_reg_top_hostb_mpeg_ser_mode_len,
			0);
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_top_hostb_mpeg_par_mode,
			eagle_reg_top_hostb_mpeg_par_mode_pos, eagle_reg_top_hostb_mpeg_par_mode_len,
			0);
	it950x_wr_reg(dev, Processor_OFDM, 0xF714, 0);

	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2_sw_rst,
			eagle_reg_mp2_sw_rst_pos, eagle_reg_mp2_sw_rst_len,
			1);

	/* Reset EP5 */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2if2_sw_rst,
			eagle_reg_mp2if2_sw_rst_pos, eagle_reg_mp2if2_sw_rst_len,
			1);

	/* Disable EP5 */
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep5_tx_en,
			eagle_reg_ep5_tx_en_pos, eagle_reg_ep5_tx_en_len,
			0);

	/* Disable EP5 NAK */
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep5_tx_nak,
			eagle_reg_ep5_tx_nak_pos, eagle_reg_ep5_tx_nak_len,
			0);

	/* Enable EP5 */
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep5_tx_en,
			eagle_reg_ep5_tx_en_pos, eagle_reg_ep5_tx_en_len,
			1);

	/* Set EP5 transfer length */
	frameSize = EagleUser_USB20_FRAME_SIZE_DW;
	buffer[p_eagle_reg_ep5_tx_len_7_0 - p_eagle_reg_ep5_tx_len_7_0] = frameSize;
	buffer[p_eagle_reg_ep5_tx_len_15_8 - p_eagle_reg_ep5_tx_len_7_0] = (frameSize >> 8);
	it950x_wr_regs(dev, Processor_LINK, p_eagle_reg_ep5_tx_len_7_0, buffer, sizeof(buffer));

	/* Set EP5 packet size */
	packetSize = EagleUser_USB20_MAX_PACKET_SIZE / 4;
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_ep5_max_pkt, packetSize);

	/* Disable 15 SER/PAR mode */
	it950x_wr_regbits(dev, Processor_OFDM, p_mp2if_mpeg_ser_mode,
			mp2if_mpeg_ser_mode_pos, mp2if_mpeg_ser_mode_len,
			0);
	it950x_wr_regbits(dev, Processor_OFDM, p_mp2if_mpeg_par_mode,
			mp2if_mpeg_par_mode_pos, mp2if_mpeg_par_mode_len,
			0);

	/* Enable mp2if2 */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2if2_en,
			eagle_reg_mp2if2_en_pos, eagle_reg_mp2if2_en_len,
			1);

	/* Enable tsis */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_tsip_en,
			eagle_reg_tsip_en_pos, eagle_reg_tsip_en_len,
			0);
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_tsis_en,
			eagle_reg_tsis_en_pos, eagle_reg_tsis_en_len,
			1);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_ts_in_src, 0);

	/* Negate EP4 reset */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2_sw_rst,
			eagle_reg_mp2_sw_rst_pos, eagle_reg_mp2_sw_rst_len,
			0);

	/* Negate EP5 reset */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2if2_sw_rst,
			eagle_reg_mp2if2_sw_rst_pos, eagle_reg_mp2if2_sw_rst_len,
			0);

	/* Split 15 PSB to 1K + 1K and enable flow control */
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2if2_half_psb,
			eagle_reg_mp2if2_half_psb_pos, eagle_reg_mp2if2_half_psb_len,
			0);
	it950x_wr_regbits(dev, Processor_OFDM, p_eagle_reg_mp2if_stop_en,
			eagle_reg_mp2if_stop_en_pos, eagle_reg_mp2if_stop_en_len,
			1);
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_host_reverse, 0);
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep6_rx_en,
			eagle_reg_ep6_rx_en_pos, eagle_reg_ep6_rx_en_len,
			0);
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep6_rx_nak,
			eagle_reg_ep6_rx_nak_pos, eagle_reg_ep6_rx_nak_len,
			0);
	it950x_wr_regbits(dev, Processor_LINK, p_eagle_reg_ep6_rx_en,
			eagle_reg_ep6_rx_en_pos, eagle_reg_ep6_rx_en_len,
			1);
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_ep6_max_pkt, 0x80);
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_ep6_cnt_num_7_0, 0x16);

	return dev->error;
}

static int it950x_adjust_gain(struct it950x_dev *dev)
{
	int c1value = 0, c2value = 0, c3value = 0;
	int c1value_default, c2value_default, c3value_default;
	uint32_t amp_mul_max1 = 0, amp_mul_max2 = 0, amp_mul_max3 = 0;
	int i = 0, amp_mul, amp_mul_max = 0;
	int gain_X10 = dev->gain * 10;
	int overflow = 0;

	c1value_default = dev->c1val;
	c2value_default = dev->c2val;
	c3value_default = dev->c3val;

	if (c1value_default > 1023) c1value_default = c1value_default - 2048;
	if (c2value_default > 1023) c2value_default = c2value_default - 2048;
	if (c3value_default > 1023) c3value_default = c3value_default - 2048;

	amp_mul_max1 = 10000 * 1023 / abs(c1value_default);
	if (c2value_default != 0)
		amp_mul_max2 = 10000 * 1023 / abs(c2value_default);
	else
		amp_mul_max2 = 0xFFFFFFFF;
	amp_mul_max3 = 10000 * 1023 / abs(c3value_default);

	amp_mul_max = amp_mul_max1;
	if (amp_mul_max2 < amp_mul_max)
		amp_mul_max = amp_mul_max2;
	if (amp_mul_max3 < amp_mul_max)
		amp_mul_max = amp_mul_max3;

	if (gain_X10 > 0) {
		//d_amp_mul = 1;
		amp_mul = 10000;
		for (i = 0; i < gain_X10; i += 10) {
			if (amp_mul_max > amp_mul) {
				amp_mul = amp_mul * 11220 / 10000;
				c1value = c1value_default * amp_mul / 10000;
				c2value = c2value_default * amp_mul / 10000;
				c3value = c3value_default * amp_mul / 10000;
			}
			if (c1value > 0x03ff) {
				c1value = 0x03ff;
				overflow = 1;
			}
			/*if(c2value > 0x03ff) {
				c2value = 0x03ff;
				overflow = 1;
			} */
			if (c3value > 0x03ff) {
				c3value = 0x03ff;
				overflow = 1;
			}
			if (overflow)
				break;
		}
	} else if (gain_X10 < 0) {
		//d_amp_mul = 1;
		amp_mul = 10000;
		for (i = 0; i > gain_X10; i -= 10) {
			if (amp_mul_max > amp_mul) {
				//d_amp_mul *= 0.501;
				amp_mul = amp_mul * 8910 / 10000;
				c1value = c1value_default * amp_mul / 10000;
				c2value = c2value_default * amp_mul / 10000;
				c3value = c3value_default * amp_mul / 10000;
			}
			if (c1value == 0)
				overflow = 1;
			/*if(c2value==0)
				overflow = 1; */
			if (c3value == 0)
				overflow = 1;
			if (overflow)
				break;
		}
	} else {
		c1value = c1value_default;
		c2value = c2value_default;
		c3value = c3value_default;
	}

	if (c1value < 0) c1value = c1value + 2048;
	if (c2value < 0) c2value = c2value + 2048;
	if (c3value < 0) c3value = c3value + 2048;
	c1value = (c1value % 2048);
	c2value = (c2value % 2048);
	c3value = (c3value % 2048);

	//*gain = i / 10;
	//dev->calibrationInfo.outputGain = *gain;

	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c1_7_0, c1value & 0xff);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c1_10_8, c1value >> 8);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c2_7_0, c2value & 0xff);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c2_10_8, c2value >> 8);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c3_7_0, c3value & 0xff);
	it950x_wr_reg(dev, Processor_OFDM, p_eagle_reg_iqik_c3_10_8, c3value >> 8);
	return dev->error;
}

static int it950x_init(struct it950x_dev *dev)
{
	uint32_t ver_ofdm, ver_link;
	int r;

	ver_link = it9507_get_fwver(dev, Processor_LINK);
	if (ver_link == 0xffffffff) return -EIO;

	r = it950x_wr_reg(dev, Processor_LINK, second_i2c_address, 0x00);
	if (r < 0) return r;

	if (ver_link == 0) {
		/* Firmware upload required */
		r = it950x_load_firmware(dev);
		if (r < 0) return r;

		ver_link = it9507_get_fwver(dev, Processor_LINK);
		if (ver_link == 0xffffffff) return -EIO;
	}
	ver_ofdm = it9507_get_fwver(dev, Processor_OFDM);

	fprintf(stderr,
		"OFDM firmware version: 0x%08x\n"
		"LINK firmware version: 0x%08x\n",
		ver_ofdm, ver_link);

	if (ver_ofdm != DVB_OFDM_VERSION ||
	    ver_link != DVB_LINK_VERSION)
		return -ENOTSUP;

	/* IT9507_initialize */

	/* set UART -> GPIOH4 */
	it950x_wr_reg(dev, Processor_LINK, 0xD924, 0);

	/* Set I2C master clock 100k in order to support tuner I2C. */
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_lnk2ofdm_data_63_56, 0x7);
	it950x_wr_regbits(dev, Processor_OFDM, 0xFB26, 7, 1, 1);
	it950x_wr_reg(dev, Processor_OFDM, 0xFBBD, 0xE0);
	it950x_wr_reg(dev, Processor_OFDM, 0xF99A, 0);

	/* EagleUser_Initialization */

	/* restSlave */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH1), 1);
	it950x_wr_reg(dev, Processor_LINK, GPIO_EN(GPIOH1), 1);
	it950x_wr_reg(dev, Processor_LINK, GPIO_ON(GPIOH1), 1);
	usleep(10000);

	/* powerDownSlave */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH5), 0);
	it950x_wr_reg(dev, Processor_LINK, GPIO_EN(GPIOH5), 1);
	it950x_wr_reg(dev, Processor_LINK, GPIO_ON(GPIOH5), 1);

	/* rfEnable */
	it950x_wr_reg(dev, Processor_LINK, GPIO_EN(GPIOH2), 1);
	it950x_wr_reg(dev, Processor_LINK, GPIO_ON(GPIOH2), 1);

	/* uvFilter */
	it950x_wr_reg(dev, Processor_LINK, GPIO_EN(GPIOH8), 1);
	it950x_wr_reg(dev, Processor_LINK, GPIO_ON(GPIOH8), 1);

	/* RF out power down */
	it950x_wr_reg(dev, Processor_LINK, GPIO_O(GPIOH2), 0);

	/* Set the desired stream type */
	it950x_set_ts_interface(dev);

	/* Set H/W MPEG2 locked detection **/
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_lock3_out, 1);
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_padmiscdrsr, 1);

	/* Set registers for driving power 0xD830 **/
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_padmiscdr2, 0);

	/* Set registers for driving power 0xD831 **/
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_padmiscdr4, 0);

	/* Set registers for driving power 0xD832 **/
	it950x_wr_reg(dev, Processor_LINK, p_eagle_reg_top_padmiscdr8, 0);
	it950x_wr_reg(dev, Processor_OFDM, 0xFB2E, 0x11);
	it950x_wr_reg(dev, Processor_OFDM, 0xFBB3, 0x98);
	it950x_read_calibration_info(dev);

	if (dev->error) return dev->error;

	r = it950x_wr_reg(dev, Processor_OFDM, 0xF7C6, 0x1);
	if (verbose) fprintf(stderr, "AirHD Register write: %s\n", r < 0 ? "ERRROR" : "OK");
	if (r < 0) return r;

	/* Configure and power up */
	it9507_power_up(dev);
	it9507_configure(dev);
	it950x_adjust_gain(dev);

	return dev->error;
}

static int do_read(int fd, unsigned char *buf, int bytes)
{
	int r, left;

	for (left = bytes; left; ) {
		r = read(fd, buf, left);
		if (r <= 0) {
			if (r == 0) return bytes - left;
			return -errno;
		}
		left -= r;
		buf += r;
	}

	return bytes;
}

struct transfer {
	int in_flight : 1;
	uint8_t *buf;
	struct libusb_transfer *xfer;
};

static void it950x_buffer_done(struct libusb_transfer *xfer)
{
	struct transfer *t = xfer->user_data;
	t->in_flight = 0;
}

static int it950x_stream_data(struct it950x_dev *dev, int fd)
{
	const long num_bufs = 16;
	const long num_seconds = 2;
	size_t buf_len;

	struct transfer bufs[num_bufs];
	int active = 0;
	int i, r;

	buf_len = num_seconds * dev->capacity_bps / 8;
	buf_len /= num_bufs;
	buf_len -= buf_len % 0xbc;

	for (i = 0; i < num_bufs; i++) {
		struct transfer *ab = &bufs[i];
		ab->in_flight = 0;
		ab->xfer = libusb_alloc_transfer(0);
		ab->buf = malloc(buf_len);
		if (!ab->buf) {
			r = -ENOMEM;
			goto err;
		}
	}

	while (1) {
		struct transfer *ab = &bufs[active];

		while (ab->in_flight)
			libusb_handle_events(NULL);

		r = do_read(fd, ab->buf, buf_len);
		if (r < buf_len) break;

		ab->in_flight = 1;
		libusb_fill_bulk_transfer(
			ab->xfer, dev->dev, LIBUSB_ENDPOINT_OUT | 0x06,
			ab->buf, buf_len,
			it950x_buffer_done, ab,
			10000);
		r = libusb_submit_transfer(ab->xfer);
		if (r != LIBUSB_SUCCESS) {
			r = -EIO;
			break;
		}

		active = (active + 1) % num_bufs;
	}

err:
	return r;
}

struct map {
	int value;
	const char *str;
};

static struct map map_transmission_mode[] = {
	{ IT950X_TRANSMISSION_MODE_2K, "2k" },
	{ IT950X_TRANSMISSION_MODE_4K, "4k" },
	{ IT950X_TRANSMISSION_MODE_8K, "8k" },
};

static struct map map_constellation[] = {
	{ IT950X_CONSTELLATION_QPSK, "qpsk" },
	{ IT950X_CONSTELLATION_QAM_16, "qam16" },
	{ IT950X_CONSTELLATION_QAM_64, "qam64" },
};

static struct map map_guard_interval[] = {
	{ IT950X_GUARD_INTERVAL_1_4, "1/4" },
	{ IT950X_GUARD_INTERVAL_1_8, "1/8" },
	{ IT950X_GUARD_INTERVAL_1_16, "1/16" },
	{ IT950X_GUARD_INTERVAL_1_32, "1/32" },
};

static struct map map_fec[] = {
	{ IT950X_FEC_1_2, "1/2" },
	{ IT950X_FEC_2_3, "2/3" },
	{ IT950X_FEC_3_4, "3/4" },
	{ IT950X_FEC_5_6, "5/6" },
	{ IT950X_FEC_7_8, "7/8" },
};

static int lookup_map(struct map *map, size_t n, const char *str)
{
	size_t i;
	for (i = 0; i < n; i++)
		if (strcmp(map[i].str, str) == 0)
			return map[i].value;
	return -1;
}

static int usage(void)
{
	fprintf(stderr,
		"usage: sendts-it9507 [OPTIONS]\n"
		"\n"
		"  -h,--help               Print this help\n"
		"  -v,--verbose            Print more messages\n"
		"  -D,--device             Specify USB device number\n"
		"  -g,--gain               Set gain\n"
		"  -f,--frequency          Set frequency (in kHz)\n"
		"  -c,--channel            Set frequency (as channel no#)\n"
		"  -b,--bandwidth          Set bandwidth in Hz (1000 - 8000)\n"
		"  -t,--transmission-mode  Set transmission mode (2k/4k/8k)\n"
		"  -C,--constellation      Set constellation (qpsk/qam16/qam64)\n"
		"  -G,--guard-interval     Set guard interval (1/4,1/8,1/16,1/32)\n"
		"  -r,--code-rate          Set code rate (1/2,2/3,3/4,5/6,7/8)\n"
		"  -i,--cell-id            Set cell id (number)\n"
		"  -m,--muxrate            Print calculted muxrate\n"
		"\n");
	return 1;
}

static const char *format_usb_ports(const uint8_t *ports, size_t n, char *fmt)
{
	int i = 0, p = 0;
	if (n == 0) {
		fmt[0] = 0;
		return fmt;
	}
	p += sprintf(fmt, "%u", ports[0]);
	for (i = 1; i < n; i++)
		p += sprintf(&fmt[p], ".%u", ports[i]);
	return fmt;
}

static long int it950x_calc_capacity(struct it950x_dev *dev)
{
	uint64_t capacity;

	capacity = dev->bandwidth_hz * 1000;

	switch (dev->constellation) {
	case IT950X_CONSTELLATION_QPSK:
		capacity *= 2;
		break;
	case IT950X_CONSTELLATION_QAM_16:
		capacity *= 4;
		break;
	case IT950X_CONSTELLATION_QAM_64:
		capacity *= 6;
		break;
	default:
		return -1;
	}

	switch (dev->guard_interval) {
	case IT950X_GUARD_INTERVAL_1_32:
		capacity = capacity * 32 / 33;
		break;
	case IT950X_GUARD_INTERVAL_1_16:
		capacity = capacity * 16 / 17;
		break;
	case IT950X_GUARD_INTERVAL_1_8:
		capacity = capacity * 8 / 9;
		break;
	case IT950X_GUARD_INTERVAL_1_4:
		capacity = capacity * 4 / 5;
		break;
	default:
		return 1;
	}

	switch (dev->code_rate_hp) {
	case IT950X_FEC_1_2:
		capacity = capacity * 1 / 2;
		break;
	case IT950X_FEC_2_3:
		capacity = capacity * 2 / 3;
		break;
	case IT950X_FEC_3_4:
		capacity = capacity * 3 / 4;
		break;
	case IT950X_FEC_5_6:
		capacity = capacity * 5 / 6;
		break;
	case IT950X_FEC_7_8:
		capacity = capacity * 7 / 8;
		break;
	default:
		return -1;
	}
	dev->capacity_bps = capacity / 544 * 423;
	return 0;
}

int main(int argc, char **argv)
{
	static const struct option long_options[] = {
		{ "help",		no_argument, NULL, 'h' },
		{ "verbose",		no_argument, NULL, 'v' },
		{ "device",		required_argument, NULL, 'd' },
		{ "gain",		required_argument, NULL, 'g' },
		{ "frequency",		required_argument, NULL, 'f' },
		{ "channel",		required_argument, NULL, 'c' },
		{ "bandwidth",		required_argument, NULL, 'b' },
		{ "transmission-mode",	required_argument, NULL, 't' },
		{ "constellation",	required_argument, NULL, 'C' },
		{ "guard-interval",	required_argument, NULL, 'G' },
		{ "code-rate",		required_argument, NULL, 'r' },
		{ "cell-id",		required_argument, NULL, 'i' },
		{ "muxrate",		no_argument, NULL, 'm' },
	};
	static const char short_options[] = "hvd:g:f:c:b:t:C:G:r:i:m";

	struct it950x_dev dev = {
		.gain = -10,
		.frequency_khz = 794000, /* Channel 68 */
		.bandwidth_hz = 8000,
		.transmission_mode = IT950X_TRANSMISSION_MODE_8K,
		.constellation = IT950X_CONSTELLATION_QAM_64,
		.guard_interval = IT950X_GUARD_INTERVAL_1_4,
		.code_rate_hp = IT950X_FEC_2_3,
		.cell_id = 0,
	};
	libusb_context *ctx = NULL;
	libusb_device **list = NULL;
	struct libusb_device_descriptor desc;
	const char *msg = NULL;
	int i, r, opt, optindex;
	int device_number = 0, matched = 0, rate_only = 0;
	ssize_t n;

	optindex = 0;
	while ((opt=getopt_long(argc, argv, short_options, long_options, &optindex)) > 0) {
		switch (opt) {
		case 'h': usage(); return 0;
		case 'v': verbose++; break;
		case 'd': device_number = atoi(optarg); break;
		case 'g': dev.gain = atoi(optarg); break;
		case 'f': dev.frequency_khz = atoi(optarg); break;
		case 'c': dev.frequency_khz = 306000+8000*atoi(optarg); break;
		case 'b': dev.bandwidth_hz = atoi(optarg); break;
		case 't': dev.transmission_mode = lookup_map(map_transmission_mode, ARRAY_SIZE(map_transmission_mode), optarg); break;
		case 'C': dev.constellation = lookup_map(map_constellation, ARRAY_SIZE(map_constellation), optarg); break;
		case 'G': dev.guard_interval = lookup_map(map_guard_interval, ARRAY_SIZE(map_guard_interval), optarg); break;
		case 'r': dev.code_rate_hp = lookup_map(map_fec, ARRAY_SIZE(map_fec), optarg); break;
		case 'm': rate_only = 1; break;
		default: return usage();
		}
	}

	if (it950x_calc_capacity(&dev) < 0)
		return usage();

	if (rate_only) {
		fprintf(stdout, "%ld\n", dev.capacity_bps);
		return 0;
	}

	r = libusb_init(&ctx);
	if (r != LIBUSB_SUCCESS) {
		msg = "initialize usb library";
		goto error;
	}

	r = n = libusb_get_device_list(ctx, &list);
	if (r < 0) {
		msg = "unable to enumerate usb devices";
		goto error;
	}

	if (verbose) fprintf(stderr, "Devices:\n");
	for (i = matched = 0; i < n; i++) {
		uint8_t ports[8];
		char fmt[ARRAY_SIZE(ports)*4];

		libusb_get_device_descriptor(list[i], &desc);
		r = libusb_get_port_numbers(list[i], ports, ARRAY_SIZE(ports));
		if (desc.idVendor != 0x048D || desc.idProduct != 0x9507)
			continue;

		if (verbose)
			fprintf(stderr, "#%d [%d-%d] %04x:%04x %s\n",
				matched,
				libusb_get_bus_number(list[i]),
				libusb_get_device_address(list[i]),
				desc.idVendor,
				desc.idProduct,
				format_usb_ports(ports, r, fmt));

		if (matched == device_number)
			libusb_open(list[i], &dev.dev);
		matched ++;
	}
	libusb_free_device_list(list, 1);
	if (verbose) fprintf(stderr, "\n");

	if (!dev.dev) {
		msg = "unable to open device";
		r = LIBUSB_ERROR_OTHER;
		goto error;
	}

	r = libusb_claim_interface(dev.dev, 0);
	if (r != LIBUSB_SUCCESS) {
		msg = "failed to claim interface";
		goto error;
	}

	it950x_init(&dev);
	r = it950x_stream_data(&dev, STDIN_FILENO);
	if (r < 0) fprintf(stderr, "streaming failed, r=%d\n", r);

	libusb_close(dev.dev);
error:
	if (ctx) libusb_exit(ctx);
	if (!msg) return 0;
	fprintf(stderr, "error: %s: %s\n", msg, libusb_error_name(r));
	return 1;
}
